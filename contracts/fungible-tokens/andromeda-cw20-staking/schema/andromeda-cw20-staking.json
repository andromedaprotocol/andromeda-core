{
  "contract_name": "andromeda-cw20-staking",
  "contract_version": "0.2.0",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "staking_token"
    ],
    "properties": {
      "additional_rewards": {
        "description": "Any rewards in addition to the staking token. This list cannot include the staking token.",
        "type": [
          "array",
          "null"
        ],
        "items": {
          "$ref": "#/definitions/RewardTokenUnchecked"
        }
      },
      "kernel_address": {
        "type": [
          "string",
          "null"
        ]
      },
      "staking_token": {
        "description": "The cw20 token that can be staked.",
        "type": "string"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "AllocationConfig": {
        "type": "object",
        "required": [
          "cycle_duration",
          "cycle_rewards",
          "init_timestamp",
          "till_timestamp"
        ],
        "properties": {
          "cycle_duration": {
            "description": "Cycle duration in timestamps",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "cycle_rewards": {
            "description": "Rewards distributed during the 1st cycle.",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "init_timestamp": {
            "description": "Timestamp from which Rewards will start getting accrued against the staked LP tokens",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "reward_increase": {
            "description": "Percent increase in Rewards per cycle",
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "till_timestamp": {
            "description": "Timestamp till which Rewards will be accrued. No staking rewards are accrued beyond this timestamp",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        }
      },
      "AssetInfoBase_for_String": {
        "description": "Represents the type of an fungible asset\n\nEach **asset info** instance can be one of three variants:\n\n- Native SDK coins. To create an **asset info** instance of this type, provide the denomination. - CW20 tokens. To create an **asset info** instance of this type, provide the contract address. - CW1155 tokens. To create an **asset info** instance of this type, provide the contract address and token ID.",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "native"
            ],
            "properties": {
              "native": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "cw20"
            ],
            "properties": {
              "cw20": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "cw1155"
            ],
            "properties": {
              "cw1155": {
                "type": "array",
                "items": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "RewardTokenUnchecked": {
        "type": "object",
        "required": [
          "asset_info"
        ],
        "properties": {
          "allocation_config": {
            "anyOf": [
              {
                "$ref": "#/definitions/AllocationConfig"
              },
              {
                "type": "null"
              }
            ]
          },
          "asset_info": {
            "$ref": "#/definitions/AssetInfoBase_for_String"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "andr_receive"
        ],
        "properties": {
          "andr_receive": {
            "$ref": "#/definitions/AndromedaMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "a_m_p_receive"
        ],
        "properties": {
          "a_m_p_receive": {
            "$ref": "#/definitions/AMPPkt"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "receive"
        ],
        "properties": {
          "receive": {
            "$ref": "#/definitions/Cw20ReceiveMsg"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Add `reward_token` as another reward token. Owner only.",
        "type": "object",
        "required": [
          "add_reward_token"
        ],
        "properties": {
          "add_reward_token": {
            "type": "object",
            "required": [
              "reward_token"
            ],
            "properties": {
              "reward_token": {
                "$ref": "#/definitions/RewardTokenUnchecked"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Unstakes the specified amount of assets, or all if not specified. The user's pending rewards and indexes are updated for each additional reward token.",
        "type": "object",
        "required": [
          "unstake_tokens"
        ],
        "properties": {
          "unstake_tokens": {
            "type": "object",
            "properties": {
              "amount": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Uint128"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Claims any outstanding rewards from the addtional reward tokens.",
        "type": "object",
        "required": [
          "claim_rewards"
        ],
        "properties": {
          "claim_rewards": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Updates the global reward index for the specified reward tokens or all of the specified ones if None. Funds may be sent along with this.",
        "type": "object",
        "required": [
          "update_global_indexes"
        ],
        "properties": {
          "update_global_indexes": {
            "type": "object",
            "properties": {
              "asset_infos": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "$ref": "#/definitions/AssetInfoBase_for_String"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "ADORecipient": {
        "description": "ADOs use a default Receive message for handling funds, this struct states that the recipient is an ADO and may attach the data field to the Receive message",
        "type": "object",
        "required": [
          "address"
        ],
        "properties": {
          "address": {
            "description": "Addr can also be a human-readable identifier used in a app contract.",
            "allOf": [
              {
                "$ref": "#/definitions/AndrAddress"
              }
            ]
          },
          "msg": {
            "anyOf": [
              {
                "$ref": "#/definitions/Binary"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "AMPMsg": {
        "description": "This struct defines how the kernel parses and relays messages between ADOs It contains a simple recipient string which may use our namespacing implementation or a simple contract address If the desired recipient is via IBC then namespacing must be employed The attached message must be a binary encoded execute message for the receiving ADO Funds can be attached for an individual message and will be attached accordingly",
        "type": "object",
        "required": [
          "exit_at_error",
          "funds",
          "message",
          "recipient",
          "reply_on"
        ],
        "properties": {
          "exit_at_error": {
            "description": "Determines whether the operation should terminate or proceed upon a failed message",
            "type": "boolean"
          },
          "funds": {
            "description": "Any funds to be attached to the message, defaults to an empty vector",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "gas_limit": {
            "description": "An optional imposed gas limit for the message",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "message": {
            "description": "The message to be sent to the recipient",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          },
          "recipient": {
            "description": "The message recipient, can be a contract/wallet address or a namespaced URI",
            "type": "string"
          },
          "reply_on": {
            "description": "When the message should reply, defaults to Always",
            "allOf": [
              {
                "$ref": "#/definitions/ReplyOn"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "AMPPkt": {
        "description": "An Andromeda packet contains all message protocol related data, this is what is sent between ADOs when communicating It contains an original sender, if used for authorisation the sender must be authorised The previous sender is the one who sent the message A packet may contain several messages which allows for message batching",
        "type": "object",
        "required": [
          "messages",
          "origin",
          "previous_sender"
        ],
        "properties": {
          "messages": {
            "description": "Any messages associated with the packet",
            "type": "array",
            "items": {
              "$ref": "#/definitions/AMPMsg"
            }
          },
          "origin": {
            "description": "The original sender of the packet, immutable, can be retrieved with `AMPPkt.get_origin`",
            "type": "string"
          },
          "previous_sender": {
            "description": "The previous sender of the packet, immutable, can be retrieved with `AMPPkt.get_previous_sender`",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "AllocationConfig": {
        "type": "object",
        "required": [
          "cycle_duration",
          "cycle_rewards",
          "init_timestamp",
          "till_timestamp"
        ],
        "properties": {
          "cycle_duration": {
            "description": "Cycle duration in timestamps",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "cycle_rewards": {
            "description": "Rewards distributed during the 1st cycle.",
            "allOf": [
              {
                "$ref": "#/definitions/Uint128"
              }
            ]
          },
          "init_timestamp": {
            "description": "Timestamp from which Rewards will start getting accrued against the staked LP tokens",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "reward_increase": {
            "description": "Percent increase in Rewards per cycle",
            "anyOf": [
              {
                "$ref": "#/definitions/Decimal"
              },
              {
                "type": "null"
              }
            ]
          },
          "till_timestamp": {
            "description": "Timestamp till which Rewards will be accrued. No staking rewards are accrued beyond this timestamp",
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          }
        }
      },
      "AndrAddress": {
        "type": "object",
        "required": [
          "identifier"
        ],
        "properties": {
          "identifier": {
            "description": "Can be either an address or identifier of an ADO in a app.",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "AndromedaMsg": {
        "oneOf": [
          {
            "description": "Standard Messages",
            "type": "object",
            "required": [
              "receive"
            ],
            "properties": {
              "receive": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Binary"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_owner"
            ],
            "properties": {
              "update_owner": {
                "type": "object",
                "required": [
                  "address"
                ],
                "properties": {
                  "address": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_operators"
            ],
            "properties": {
              "update_operators": {
                "type": "object",
                "required": [
                  "operators"
                ],
                "properties": {
                  "operators": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_app_contract"
            ],
            "properties": {
              "update_app_contract": {
                "type": "object",
                "required": [
                  "address"
                ],
                "properties": {
                  "address": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "withdraw"
            ],
            "properties": {
              "withdraw": {
                "type": "object",
                "properties": {
                  "recipient": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Recipient"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "tokens_to_withdraw": {
                    "type": [
                      "array",
                      "null"
                    ],
                    "items": {
                      "$ref": "#/definitions/Withdrawal"
                    }
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "register_module"
            ],
            "properties": {
              "register_module": {
                "type": "object",
                "required": [
                  "module"
                ],
                "properties": {
                  "module": {
                    "$ref": "#/definitions/Module"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "deregister_module"
            ],
            "properties": {
              "deregister_module": {
                "type": "object",
                "required": [
                  "module_idx"
                ],
                "properties": {
                  "module_idx": {
                    "$ref": "#/definitions/Uint64"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "alter_module"
            ],
            "properties": {
              "alter_module": {
                "type": "object",
                "required": [
                  "module",
                  "module_idx"
                ],
                "properties": {
                  "module": {
                    "$ref": "#/definitions/Module"
                  },
                  "module_idx": {
                    "$ref": "#/definitions/Uint64"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "refresh_address"
            ],
            "properties": {
              "refresh_address": {
                "type": "object",
                "required": [
                  "contract"
                ],
                "properties": {
                  "contract": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "refresh_addresses"
            ],
            "properties": {
              "refresh_addresses": {
                "type": "object",
                "properties": {
                  "limit": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "start_after": {
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "AssetInfoBase_for_String": {
        "description": "Represents the type of an fungible asset\n\nEach **asset info** instance can be one of three variants:\n\n- Native SDK coins. To create an **asset info** instance of this type, provide the denomination. - CW20 tokens. To create an **asset info** instance of this type, provide the contract address. - CW1155 tokens. To create an **asset info** instance of this type, provide the contract address and token ID.",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "native"
            ],
            "properties": {
              "native": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "cw20"
            ],
            "properties": {
              "cw20": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "cw1155"
            ],
            "properties": {
              "cw1155": {
                "type": "array",
                "items": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "string"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Cw20ReceiveMsg": {
        "description": "Cw20ReceiveMsg should be de/serialized under `Receive()` variant in a ExecuteMsg",
        "type": "object",
        "required": [
          "amount",
          "msg",
          "sender"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "msg": {
            "$ref": "#/definitions/Binary"
          },
          "sender": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "Module": {
        "description": "A struct describing a token module, provided with the instantiation message this struct is used to record the info about the module and how/if it should be instantiated",
        "type": "object",
        "required": [
          "address",
          "is_mutable"
        ],
        "properties": {
          "address": {
            "type": "string"
          },
          "is_mutable": {
            "type": "boolean"
          },
          "module_name": {
            "type": [
              "string",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "Recipient": {
        "oneOf": [
          {
            "description": "An address that is not another ADO. It is assumed that it is a valid address.",
            "type": "object",
            "required": [
              "addr"
            ],
            "properties": {
              "addr": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "a_d_o"
            ],
            "properties": {
              "a_d_o": {
                "$ref": "#/definitions/ADORecipient"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ReplyOn": {
        "description": "Use this to define when the contract gets a response callback. If you only need it for errors or success you can select just those in order to save gas.",
        "oneOf": [
          {
            "description": "Always perform a callback after SubMsg is processed",
            "type": "string",
            "enum": [
              "always"
            ]
          },
          {
            "description": "Only callback if SubMsg returned an error, no callback on success case",
            "type": "string",
            "enum": [
              "error"
            ]
          },
          {
            "description": "Only callback if SubMsg was successful, no callback on error case",
            "type": "string",
            "enum": [
              "success"
            ]
          },
          {
            "description": "Never make a callback - this is like the original CosmosMsg semantics",
            "type": "string",
            "enum": [
              "never"
            ]
          }
        ]
      },
      "RewardTokenUnchecked": {
        "type": "object",
        "required": [
          "asset_info"
        ],
        "properties": {
          "allocation_config": {
            "anyOf": [
              {
                "$ref": "#/definitions/AllocationConfig"
              },
              {
                "type": "null"
              }
            ]
          },
          "asset_info": {
            "$ref": "#/definitions/AssetInfoBase_for_String"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      },
      "Withdrawal": {
        "type": "object",
        "required": [
          "token"
        ],
        "properties": {
          "token": {
            "type": "string"
          },
          "withdrawal_type": {
            "anyOf": [
              {
                "$ref": "#/definitions/WithdrawalType"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "WithdrawalType": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "amount"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "percentage"
            ],
            "properties": {
              "percentage": {
                "$ref": "#/definitions/Decimal"
              }
            },
            "additionalProperties": false
          }
        ]
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "type": "object",
        "required": [
          "andr_query"
        ],
        "properties": {
          "andr_query": {
            "$ref": "#/definitions/AndromedaQuery"
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the config of the contract.",
        "type": "object",
        "required": [
          "config"
        ],
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Gets the state of the contract.",
        "type": "object",
        "required": [
          "state"
        ],
        "properties": {
          "state": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns a `StakerResponse` for the given staker. The pending rewards are updated to the present index.",
        "type": "object",
        "required": [
          "staker"
        ],
        "properties": {
          "staker": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Returns a `Vec<StakerResponse>` for range of stakers. The pending rewards are updated to the present index for each staker.",
        "type": "object",
        "required": [
          "stakers"
        ],
        "properties": {
          "stakers": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Queries the current timestamp.",
        "type": "object",
        "required": [
          "timestamp"
        ],
        "properties": {
          "timestamp": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "AndromedaQuery": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "get"
            ],
            "properties": {
              "get": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Binary"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "operators"
            ],
            "properties": {
              "operators": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "type": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "kernel_address"
            ],
            "properties": {
              "kernel_address": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "original_publisher"
            ],
            "properties": {
              "original_publisher": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "block_height_upon_creation"
            ],
            "properties": {
              "block_height_upon_creation": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "is_operator"
            ],
            "properties": {
              "is_operator": {
                "type": "object",
                "required": [
                  "address"
                ],
                "properties": {
                  "address": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "module"
            ],
            "properties": {
              "module": {
                "type": "object",
                "required": [
                  "id"
                ],
                "properties": {
                  "id": {
                    "$ref": "#/definitions/Uint64"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "module_ids"
            ],
            "properties": {
              "module_ids": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "version"
            ],
            "properties": {
              "version": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "andr_query": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AndromedaQuery",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "get"
          ],
          "properties": {
            "get": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Binary"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "owner"
          ],
          "properties": {
            "owner": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "operators"
          ],
          "properties": {
            "operators": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "type"
          ],
          "properties": {
            "type": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "kernel_address"
          ],
          "properties": {
            "kernel_address": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "original_publisher"
          ],
          "properties": {
            "original_publisher": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "block_height_upon_creation"
          ],
          "properties": {
            "block_height_upon_creation": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "is_operator"
          ],
          "properties": {
            "is_operator": {
              "type": "object",
              "required": [
                "address"
              ],
              "properties": {
                "address": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "module"
          ],
          "properties": {
            "module": {
              "type": "object",
              "required": [
                "id"
              ],
              "properties": {
                "id": {
                  "$ref": "#/definitions/Uint64"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "module_ids"
          ],
          "properties": {
            "module_ids": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "version"
          ],
          "properties": {
            "version": {
              "type": "object",
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ],
      "definitions": {
        "Binary": {
          "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "config": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Config",
      "type": "object",
      "required": [
        "number_of_reward_tokens",
        "staking_token"
      ],
      "properties": {
        "number_of_reward_tokens": {
          "description": "The current number of reward tokens, cannot exceed `MAX_REWARD_TOKENS`.",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "staking_token": {
          "description": "The token accepted for staking.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "staker": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "StakerResponse",
      "type": "object",
      "required": [
        "address",
        "balance",
        "pending_rewards",
        "share"
      ],
      "properties": {
        "address": {
          "description": "Address of the staker.",
          "type": "string"
        },
        "balance": {
          "description": "The staker's balance of tokens.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "pending_rewards": {
          "description": "The staker's pending rewards represented as [(token_1, amount_1), ..., (token_n, amount_n)]",
          "type": "array",
          "items": {
            "type": "array",
            "items": [
              {
                "type": "string"
              },
              {
                "$ref": "#/definitions/Uint128"
              }
            ],
            "maxItems": 2,
            "minItems": 2
          }
        },
        "share": {
          "description": "The staker's share of the tokens.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "stakers": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_StakerResponse",
      "type": "array",
      "items": {
        "$ref": "#/definitions/StakerResponse"
      },
      "definitions": {
        "StakerResponse": {
          "type": "object",
          "required": [
            "address",
            "balance",
            "pending_rewards",
            "share"
          ],
          "properties": {
            "address": {
              "description": "Address of the staker.",
              "type": "string"
            },
            "balance": {
              "description": "The staker's balance of tokens.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            },
            "pending_rewards": {
              "description": "The staker's pending rewards represented as [(token_1, amount_1), ..., (token_n, amount_n)]",
              "type": "array",
              "items": {
                "type": "array",
                "items": [
                  {
                    "type": "string"
                  },
                  {
                    "$ref": "#/definitions/Uint128"
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            "share": {
              "description": "The staker's share of the tokens.",
              "allOf": [
                {
                  "$ref": "#/definitions/Uint128"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "state": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "State",
      "type": "object",
      "required": [
        "total_share"
      ],
      "properties": {
        "total_share": {
          "description": "The total share of the staking token in the contract.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "timestamp": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "uint64",
      "type": "integer",
      "format": "uint64",
      "minimum": 0.0
    }
  }
}
