{
  "contract_name": "andromeda-cw20",
  "contract_version": "1.0.0-rc.1",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "decimals",
      "initial_balances",
      "kernel_address",
      "name",
      "symbol"
    ],
    "properties": {
      "decimals": {
        "type": "integer",
        "format": "uint8",
        "minimum": 0.0
      },
      "initial_balances": {
        "type": "array",
        "items": {
          "$ref": "#/definitions/Cw20Coin"
        }
      },
      "kernel_address": {
        "type": "string"
      },
      "marketing": {
        "anyOf": [
          {
            "$ref": "#/definitions/InstantiateMarketingInfo"
          },
          {
            "type": "null"
          }
        ]
      },
      "mint": {
        "anyOf": [
          {
            "$ref": "#/definitions/MinterResponse"
          },
          {
            "type": "null"
          }
        ]
      },
      "modules": {
        "type": [
          "array",
          "null"
        ],
        "items": {
          "$ref": "#/definitions/Module"
        }
      },
      "name": {
        "type": "string"
      },
      "owner": {
        "type": [
          "string",
          "null"
        ]
      },
      "symbol": {
        "type": "string"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "AndrAddr": {
        "description": "An address that can be used within the Andromeda ecosystem. Inspired by the cosmwasm-std `Addr` type. https://github.com/CosmWasm/cosmwasm/blob/2a1c698520a1aacedfe3f4803b0d7d653892217a/packages/std/src/addresses.rs#L33\n\nThis address can be one of two things: 1. A valid human readable address e.g. `cosmos1...` 2. A valid Andromeda VFS path e.g. `/home/user/app/component`\n\nVFS paths can be local in the case of an app and can be done by referencing `./component` they can also contain protocols for cross chain communication. A VFS path is usually structured as so:\n\n`<protocol>://<chain (required if ibc used)>/<path>` or `ibc://cosmoshub-4/user/app/component`",
        "type": "string",
        "pattern": "(^((([A-Za-z0-9]+://)?([A-Za-z0-9.\\-_]{2,40}/)))?((~[a-z0-9]{2,}|(lib|home))(/[A-Za-z0-9.\\-_]{2,40}?)*(/)?)$)|(^(~[a-z0-9]{2,}|/(lib|home))(/[A-Za-z0-9.\\-_]{2,40}?)*(/)?$)|(^[a-z0-9]{2,}$)|(^\\.(/[A-Za-z0-9.\\-_]{2,40}?)*(/)?$)"
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Cw20Coin": {
        "type": "object",
        "required": [
          "address",
          "amount"
        ],
        "properties": {
          "address": {
            "type": "string"
          },
          "amount": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "EmbeddedLogo": {
        "description": "This is used to store the logo on the blockchain in an accepted format. Enforce maximum size of 5KB on all variants.",
        "oneOf": [
          {
            "description": "Store the Logo as an SVG file. The content must conform to the spec at https://en.wikipedia.org/wiki/Scalable_Vector_Graphics (The contract should do some light-weight sanity-check validation)",
            "type": "object",
            "required": [
              "svg"
            ],
            "properties": {
              "svg": {
                "$ref": "#/definitions/Binary"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Store the Logo as a PNG file. This will likely only support up to 64x64 or so within the 5KB limit.",
            "type": "object",
            "required": [
              "png"
            ],
            "properties": {
              "png": {
                "$ref": "#/definitions/Binary"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "InstantiateMarketingInfo": {
        "type": "object",
        "properties": {
          "description": {
            "type": [
              "string",
              "null"
            ]
          },
          "logo": {
            "anyOf": [
              {
                "$ref": "#/definitions/Logo"
              },
              {
                "type": "null"
              }
            ]
          },
          "marketing": {
            "type": [
              "string",
              "null"
            ]
          },
          "project": {
            "type": [
              "string",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "Logo": {
        "description": "This is used for uploading logo data, or setting it in InstantiateData",
        "oneOf": [
          {
            "description": "A reference to an externally hosted logo. Must be a valid HTTP or HTTPS URL.",
            "type": "object",
            "required": [
              "url"
            ],
            "properties": {
              "url": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Logo content stored on the blockchain. Enforce maximum size of 5KB on all variants",
            "type": "object",
            "required": [
              "embedded"
            ],
            "properties": {
              "embedded": {
                "$ref": "#/definitions/EmbeddedLogo"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "MinterResponse": {
        "type": "object",
        "required": [
          "minter"
        ],
        "properties": {
          "cap": {
            "description": "cap is a hard cap on total supply that can be achieved by minting. Note that this refers to total_supply. If None, there is unlimited cap.",
            "anyOf": [
              {
                "$ref": "#/definitions/Uint128"
              },
              {
                "type": "null"
              }
            ]
          },
          "minter": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Module": {
        "description": "A struct describing a token module, provided with the instantiation message this struct is used to record the info about the module and how/if it should be instantiated",
        "type": "object",
        "required": [
          "address",
          "is_mutable"
        ],
        "properties": {
          "address": {
            "$ref": "#/definitions/AndrAddr"
          },
          "is_mutable": {
            "type": "boolean"
          },
          "name": {
            "type": [
              "string",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Transfer is a base message to move tokens to another account without triggering actions",
        "type": "object",
        "required": [
          "transfer"
        ],
        "properties": {
          "transfer": {
            "type": "object",
            "required": [
              "amount",
              "recipient"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "recipient": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Burn is a base message to destroy tokens forever",
        "type": "object",
        "required": [
          "burn"
        ],
        "properties": {
          "burn": {
            "type": "object",
            "required": [
              "amount"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Send is a base message to transfer tokens to a contract and trigger an action on the receiving contract.",
        "type": "object",
        "required": [
          "send"
        ],
        "properties": {
          "send": {
            "type": "object",
            "required": [
              "amount",
              "contract",
              "msg"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "contract": {
                "type": "string"
              },
              "msg": {
                "$ref": "#/definitions/Binary"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with \"approval\" extension. Allows spender to access an additional amount tokens from the owner's (env.sender) account. If expires is Some(), overwrites current allowance expiration with this one.",
        "type": "object",
        "required": [
          "increase_allowance"
        ],
        "properties": {
          "increase_allowance": {
            "type": "object",
            "required": [
              "amount",
              "spender"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "expires": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Expiration"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "spender": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with \"approval\" extension. Lowers the spender's access of tokens from the owner's (env.sender) account by amount. If expires is Some(), overwrites current allowance expiration with this one.",
        "type": "object",
        "required": [
          "decrease_allowance"
        ],
        "properties": {
          "decrease_allowance": {
            "type": "object",
            "required": [
              "amount",
              "spender"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "expires": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Expiration"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "spender": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with \"approval\" extension. Transfers amount tokens from owner -> recipient if `env.sender` has sufficient pre-approval.",
        "type": "object",
        "required": [
          "transfer_from"
        ],
        "properties": {
          "transfer_from": {
            "type": "object",
            "required": [
              "amount",
              "owner",
              "recipient"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "owner": {
                "type": "string"
              },
              "recipient": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with \"approval\" extension. Sends amount tokens from owner -> contract if `env.sender` has sufficient pre-approval.",
        "type": "object",
        "required": [
          "send_from"
        ],
        "properties": {
          "send_from": {
            "type": "object",
            "required": [
              "amount",
              "contract",
              "msg",
              "owner"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "contract": {
                "type": "string"
              },
              "msg": {
                "$ref": "#/definitions/Binary"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with \"approval\" extension. Destroys tokens forever",
        "type": "object",
        "required": [
          "burn_from"
        ],
        "properties": {
          "burn_from": {
            "type": "object",
            "required": [
              "amount",
              "owner"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "owner": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with the \"mintable\" extension. If authorized, creates amount new tokens and adds to the recipient balance.",
        "type": "object",
        "required": [
          "mint"
        ],
        "properties": {
          "mint": {
            "type": "object",
            "required": [
              "amount",
              "recipient"
            ],
            "properties": {
              "amount": {
                "$ref": "#/definitions/Uint128"
              },
              "recipient": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with the \"marketing\" extension. If authorized, updates marketing metadata. Setting None/null for any of these will leave it unchanged. Setting Some(\"\") will clear this field on the contract storage",
        "type": "object",
        "required": [
          "update_marketing"
        ],
        "properties": {
          "update_marketing": {
            "type": "object",
            "properties": {
              "description": {
                "description": "A longer description of the token and it's utility. Designed for tooltips or such",
                "type": [
                  "string",
                  "null"
                ]
              },
              "marketing": {
                "description": "The address (if any) who can update this data structure",
                "type": [
                  "string",
                  "null"
                ]
              },
              "project": {
                "description": "A URL pointing to the project behind this token.",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "If set as the \"marketing\" role on the contract, upload a new URL, SVG, or PNG for the token",
        "type": "object",
        "required": [
          "upload_logo"
        ],
        "properties": {
          "upload_logo": {
            "$ref": "#/definitions/Logo"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "amp_receive"
        ],
        "properties": {
          "amp_receive": {
            "$ref": "#/definitions/AMPPkt"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "ownership"
        ],
        "properties": {
          "ownership": {
            "$ref": "#/definitions/OwnershipMessage"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_kernel_address"
        ],
        "properties": {
          "update_kernel_address": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "$ref": "#/definitions/Addr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_app_contract"
        ],
        "properties": {
          "update_app_contract": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "permissioning"
        ],
        "properties": {
          "permissioning": {
            "$ref": "#/definitions/PermissioningMessage"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "register_module"
        ],
        "properties": {
          "register_module": {
            "type": "object",
            "required": [
              "module"
            ],
            "properties": {
              "module": {
                "$ref": "#/definitions/Module"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "deregister_module"
        ],
        "properties": {
          "deregister_module": {
            "type": "object",
            "required": [
              "module_idx"
            ],
            "properties": {
              "module_idx": {
                "$ref": "#/definitions/Uint64"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "alter_module"
        ],
        "properties": {
          "alter_module": {
            "type": "object",
            "required": [
              "module",
              "module_idx"
            ],
            "properties": {
              "module": {
                "$ref": "#/definitions/Module"
              },
              "module_idx": {
                "$ref": "#/definitions/Uint64"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "AMPCtx": {
        "type": "object",
        "required": [
          "id",
          "origin",
          "previous_sender"
        ],
        "properties": {
          "id": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "origin": {
            "type": "string"
          },
          "origin_username": {
            "anyOf": [
              {
                "$ref": "#/definitions/AndrAddr"
              },
              {
                "type": "null"
              }
            ]
          },
          "previous_sender": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "AMPMsg": {
        "description": "This struct defines how the kernel parses and relays messages between ADOs If the desired recipient is via IBC then namespacing must be employed The attached message must be a binary encoded execute message for the receiving ADO Funds can be attached for an individual message and will be attached accordingly",
        "type": "object",
        "required": [
          "config",
          "funds",
          "message",
          "recipient"
        ],
        "properties": {
          "config": {
            "description": "When the message should reply, defaults to Always",
            "allOf": [
              {
                "$ref": "#/definitions/AMPMsgConfig"
              }
            ]
          },
          "funds": {
            "description": "Any funds to be attached to the message, defaults to an empty vector",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "message": {
            "description": "The message to be sent to the recipient",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          },
          "recipient": {
            "description": "The message recipient, can be a contract/wallet address or a namespaced URI",
            "allOf": [
              {
                "$ref": "#/definitions/AndrAddr"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "AMPMsgConfig": {
        "description": "The configuration of the message to be sent.\n\nUsed when a sub message is generated for the given AMP Msg (only used in the case of Wasm Messages).",
        "type": "object",
        "required": [
          "direct",
          "exit_at_error",
          "reply_on"
        ],
        "properties": {
          "direct": {
            "description": "Whether to send the message directly to the given recipient",
            "type": "boolean"
          },
          "exit_at_error": {
            "description": "Determines whether the operation should terminate or proceed upon a failed message",
            "type": "boolean"
          },
          "gas_limit": {
            "description": "An optional imposed gas limit for the message",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "ibc_config": {
            "anyOf": [
              {
                "$ref": "#/definitions/IBCConfig"
              },
              {
                "type": "null"
              }
            ]
          },
          "reply_on": {
            "description": "When the message should reply, defaults to Always",
            "allOf": [
              {
                "$ref": "#/definitions/ReplyOn"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "AMPPkt": {
        "description": "An Andromeda packet contains all message protocol related data, this is what is sent between ADOs when communicating It contains an original sender, if used for authorisation the sender must be authorised The previous sender is the one who sent the message A packet may contain several messages which allows for message batching",
        "type": "object",
        "required": [
          "ctx",
          "messages"
        ],
        "properties": {
          "ctx": {
            "$ref": "#/definitions/AMPCtx"
          },
          "messages": {
            "description": "Any messages associated with the packet",
            "type": "array",
            "items": {
              "$ref": "#/definitions/AMPMsg"
            }
          }
        },
        "additionalProperties": false
      },
      "Addr": {
        "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
        "type": "string"
      },
      "AndrAddr": {
        "description": "An address that can be used within the Andromeda ecosystem. Inspired by the cosmwasm-std `Addr` type. https://github.com/CosmWasm/cosmwasm/blob/2a1c698520a1aacedfe3f4803b0d7d653892217a/packages/std/src/addresses.rs#L33\n\nThis address can be one of two things: 1. A valid human readable address e.g. `cosmos1...` 2. A valid Andromeda VFS path e.g. `/home/user/app/component`\n\nVFS paths can be local in the case of an app and can be done by referencing `./component` they can also contain protocols for cross chain communication. A VFS path is usually structured as so:\n\n`<protocol>://<chain (required if ibc used)>/<path>` or `ibc://cosmoshub-4/user/app/component`",
        "type": "string",
        "pattern": "(^((([A-Za-z0-9]+://)?([A-Za-z0-9.\\-_]{2,40}/)))?((~[a-z0-9]{2,}|(lib|home))(/[A-Za-z0-9.\\-_]{2,40}?)*(/)?)$)|(^(~[a-z0-9]{2,}|/(lib|home))(/[A-Za-z0-9.\\-_]{2,40}?)*(/)?$)|(^[a-z0-9]{2,}$)|(^\\.(/[A-Za-z0-9.\\-_]{2,40}?)*(/)?$)"
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "EmbeddedLogo": {
        "description": "This is used to store the logo on the blockchain in an accepted format. Enforce maximum size of 5KB on all variants.",
        "oneOf": [
          {
            "description": "Store the Logo as an SVG file. The content must conform to the spec at https://en.wikipedia.org/wiki/Scalable_Vector_Graphics (The contract should do some light-weight sanity-check validation)",
            "type": "object",
            "required": [
              "svg"
            ],
            "properties": {
              "svg": {
                "$ref": "#/definitions/Binary"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Store the Logo as a PNG file. This will likely only support up to 64x64 or so within the 5KB limit.",
            "type": "object",
            "required": [
              "png"
            ],
            "properties": {
              "png": {
                "$ref": "#/definitions/Binary"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Expiration": {
        "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
        "oneOf": [
          {
            "description": "AtHeight will expire when `env.block.height` >= height",
            "type": "object",
            "required": [
              "at_height"
            ],
            "properties": {
              "at_height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "AtTime will expire when `env.block.time` >= time",
            "type": "object",
            "required": [
              "at_time"
            ],
            "properties": {
              "at_time": {
                "$ref": "#/definitions/Timestamp"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Never will never expire. Used to express the empty variant",
            "type": "object",
            "required": [
              "never"
            ],
            "properties": {
              "never": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "IBCConfig": {
        "type": "object",
        "properties": {
          "recovery_addr": {
            "anyOf": [
              {
                "$ref": "#/definitions/AndrAddr"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "Logo": {
        "description": "This is used for uploading logo data, or setting it in InstantiateData",
        "oneOf": [
          {
            "description": "A reference to an externally hosted logo. Must be a valid HTTP or HTTPS URL.",
            "type": "object",
            "required": [
              "url"
            ],
            "properties": {
              "url": {
                "type": "string"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Logo content stored on the blockchain. Enforce maximum size of 5KB on all variants",
            "type": "object",
            "required": [
              "embedded"
            ],
            "properties": {
              "embedded": {
                "$ref": "#/definitions/EmbeddedLogo"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Module": {
        "description": "A struct describing a token module, provided with the instantiation message this struct is used to record the info about the module and how/if it should be instantiated",
        "type": "object",
        "required": [
          "address",
          "is_mutable"
        ],
        "properties": {
          "address": {
            "$ref": "#/definitions/AndrAddr"
          },
          "is_mutable": {
            "type": "boolean"
          },
          "name": {
            "type": [
              "string",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "OwnershipMessage": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "revoke_ownership_offer",
              "accept_ownership",
              "disown"
            ]
          },
          {
            "type": "object",
            "required": [
              "update_owner"
            ],
            "properties": {
              "update_owner": {
                "type": "object",
                "required": [
                  "new_owner"
                ],
                "properties": {
                  "expiration": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "new_owner": {
                    "$ref": "#/definitions/Addr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Permission": {
        "description": "An enum to represent a user's permission for an action\n\n- **Blacklisted** - The user cannot perform the action until after the provided expiration - **Limited** - The user can perform the action while uses are remaining and before the provided expiration **for a permissioned action** - **Whitelisted** - The user can perform the action until the provided expiration **for a permissioned action**\n\nExpiration defaults to `Never` if not provided",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "blacklisted"
            ],
            "properties": {
              "blacklisted": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Expiration"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "limited"
            ],
            "properties": {
              "limited": {
                "type": "object",
                "required": [
                  "uses"
                ],
                "properties": {
                  "expiration": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "uses": {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "whitelisted"
            ],
            "properties": {
              "whitelisted": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Expiration"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "PermissioningMessage": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "set_permission"
            ],
            "properties": {
              "set_permission": {
                "type": "object",
                "required": [
                  "action",
                  "actor",
                  "permission"
                ],
                "properties": {
                  "action": {
                    "type": "string"
                  },
                  "actor": {
                    "$ref": "#/definitions/AndrAddr"
                  },
                  "permission": {
                    "$ref": "#/definitions/Permission"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "remove_permission"
            ],
            "properties": {
              "remove_permission": {
                "type": "object",
                "required": [
                  "action",
                  "actor"
                ],
                "properties": {
                  "action": {
                    "type": "string"
                  },
                  "actor": {
                    "$ref": "#/definitions/AndrAddr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "permission_action"
            ],
            "properties": {
              "permission_action": {
                "type": "object",
                "required": [
                  "action"
                ],
                "properties": {
                  "action": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "disable_action_permissioning"
            ],
            "properties": {
              "disable_action_permissioning": {
                "type": "object",
                "required": [
                  "action"
                ],
                "properties": {
                  "action": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "ReplyOn": {
        "description": "Use this to define when the contract gets a response callback. If you only need it for errors or success you can select just those in order to save gas.",
        "oneOf": [
          {
            "description": "Always perform a callback after SubMsg is processed",
            "type": "string",
            "enum": [
              "always"
            ]
          },
          {
            "description": "Only callback if SubMsg returned an error, no callback on success case",
            "type": "string",
            "enum": [
              "error"
            ]
          },
          {
            "description": "Only callback if SubMsg was successful, no callback on error case",
            "type": "string",
            "enum": [
              "success"
            ]
          },
          {
            "description": "Never make a callback - this is like the original CosmosMsg semantics",
            "type": "string",
            "enum": [
              "never"
            ]
          }
        ]
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Returns the current balance of the given address, 0 if unset. Return type: BalanceResponse. Returns metadata on the contract - name, decimals, supply, etc. Return type: TokenInfoResponse.",
        "type": "object",
        "required": [
          "token_info"
        ],
        "properties": {
          "token_info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with \"mintable\" extension. Returns who can mint and the hard cap on maximum tokens after minting. Return type: MinterResponse.",
        "type": "object",
        "required": [
          "minter"
        ],
        "properties": {
          "minter": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with \"allowance\" extension. Returns how much spender can use from owner account, 0 if unset. Return type: AllowanceResponse.",
        "type": "object",
        "required": [
          "allowance"
        ],
        "properties": {
          "allowance": {
            "type": "object",
            "required": [
              "owner",
              "spender"
            ],
            "properties": {
              "owner": {
                "type": "string"
              },
              "spender": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with \"enumerable\" extension (and \"allowances\") Returns all allowances this owner has approved. Supports pagination. Return type: AllAllowancesResponse.",
        "type": "object",
        "required": [
          "all_allowances"
        ],
        "properties": {
          "all_allowances": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "owner": {
                "type": "string"
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with \"enumerable\" extension Returns all accounts that have balances. Supports pagination. Return type: AllAccountsResponse.",
        "type": "object",
        "required": [
          "all_accounts"
        ],
        "properties": {
          "all_accounts": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with \"marketing\" extension Returns more metadata on the contract to display in the client: - description, logo, project url, etc. Return type: MarketingInfoResponse",
        "type": "object",
        "required": [
          "marketing_info"
        ],
        "properties": {
          "marketing_info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Only with \"marketing\" extension Downloads the mbeded logo data (if stored on chain). Errors if no logo data ftored for this contract. Return type: DownloadLogoResponse.",
        "type": "object",
        "required": [
          "download_logo"
        ],
        "properties": {
          "download_logo": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "ownership_request"
        ],
        "properties": {
          "ownership_request": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "kernel_address"
        ],
        "properties": {
          "kernel_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "app_contract"
        ],
        "properties": {
          "app_contract": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "original_publisher"
        ],
        "properties": {
          "original_publisher": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "block_height_upon_creation"
        ],
        "properties": {
          "block_height_upon_creation": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "version"
        ],
        "properties": {
          "version": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "balance"
        ],
        "properties": {
          "balance": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "$ref": "#/definitions/AndrAddr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "permissions"
        ],
        "properties": {
          "permissions": {
            "type": "object",
            "required": [
              "actor"
            ],
            "properties": {
              "actor": {
                "type": "string"
              },
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "permissioned_actions"
        ],
        "properties": {
          "permissioned_actions": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "module"
        ],
        "properties": {
          "module": {
            "type": "object",
            "required": [
              "id"
            ],
            "properties": {
              "id": {
                "$ref": "#/definitions/Uint64"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "module_ids"
        ],
        "properties": {
          "module_ids": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "AndrAddr": {
        "description": "An address that can be used within the Andromeda ecosystem. Inspired by the cosmwasm-std `Addr` type. https://github.com/CosmWasm/cosmwasm/blob/2a1c698520a1aacedfe3f4803b0d7d653892217a/packages/std/src/addresses.rs#L33\n\nThis address can be one of two things: 1. A valid human readable address e.g. `cosmos1...` 2. A valid Andromeda VFS path e.g. `/home/user/app/component`\n\nVFS paths can be local in the case of an app and can be done by referencing `./component` they can also contain protocols for cross chain communication. A VFS path is usually structured as so:\n\n`<protocol>://<chain (required if ibc used)>/<path>` or `ibc://cosmoshub-4/user/app/component`",
        "type": "string",
        "pattern": "(^((([A-Za-z0-9]+://)?([A-Za-z0-9.\\-_]{2,40}/)))?((~[a-z0-9]{2,}|(lib|home))(/[A-Za-z0-9.\\-_]{2,40}?)*(/)?)$)|(^(~[a-z0-9]{2,}|/(lib|home))(/[A-Za-z0-9.\\-_]{2,40}?)*(/)?$)|(^[a-z0-9]{2,}$)|(^\\.(/[A-Za-z0-9.\\-_]{2,40}?)*(/)?$)"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "all_accounts": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllAccountsResponse",
      "type": "object",
      "required": [
        "accounts"
      ],
      "properties": {
        "accounts": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "all_allowances": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllAllowancesResponse",
      "type": "object",
      "required": [
        "allowances"
      ],
      "properties": {
        "allowances": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AllowanceInfo"
          }
        }
      },
      "definitions": {
        "AllowanceInfo": {
          "type": "object",
          "required": [
            "allowance",
            "expires",
            "spender"
          ],
          "properties": {
            "allowance": {
              "$ref": "#/definitions/Uint128"
            },
            "expires": {
              "$ref": "#/definitions/Expiration"
            },
            "spender": {
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "allowance": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllowanceResponse",
      "type": "object",
      "required": [
        "allowance",
        "expires"
      ],
      "properties": {
        "allowance": {
          "$ref": "#/definitions/Uint128"
        },
        "expires": {
          "$ref": "#/definitions/Expiration"
        }
      },
      "definitions": {
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "app_contract": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AppContractResponse",
      "type": "object",
      "required": [
        "app_contract"
      ],
      "properties": {
        "app_contract": {
          "$ref": "#/definitions/Addr"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "balance": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BalanceResponse",
      "type": "object",
      "required": [
        "amount"
      ],
      "properties": {
        "amount": {
          "description": "Always returns a Coin with the requested denom. This may be of 0 amount if no such funds.",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        }
      },
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "block_height_upon_creation": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BlockHeightResponse",
      "type": "object",
      "required": [
        "block_height"
      ],
      "properties": {
        "block_height": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "download_logo": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DownloadLogoResponse",
      "description": "When we download an embedded logo, we get this response type. We expect a SPA to be able to accept this info and display it.",
      "type": "object",
      "required": [
        "data",
        "mime_type"
      ],
      "properties": {
        "data": {
          "$ref": "#/definitions/Binary"
        },
        "mime_type": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Binary": {
          "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
          "type": "string"
        }
      }
    },
    "kernel_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "KernelAddressResponse",
      "type": "object",
      "required": [
        "kernel_address"
      ],
      "properties": {
        "kernel_address": {
          "$ref": "#/definitions/Addr"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "marketing_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MarketingInfoResponse",
      "type": "object",
      "properties": {
        "description": {
          "description": "A longer description of the token and it's utility. Designed for tooltips or such",
          "type": [
            "string",
            "null"
          ]
        },
        "logo": {
          "description": "A link to the logo, or a comment there is an on-chain logo stored",
          "anyOf": [
            {
              "$ref": "#/definitions/LogoInfo"
            },
            {
              "type": "null"
            }
          ]
        },
        "marketing": {
          "description": "The address (if any) who can update this data structure",
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        },
        "project": {
          "description": "A URL pointing to the project behind this token.",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        },
        "LogoInfo": {
          "description": "This is used to display logo info, provide a link or inform there is one that can be downloaded from the blockchain itself",
          "oneOf": [
            {
              "description": "A reference to an externally hosted logo. Must be a valid HTTP or HTTPS URL.",
              "type": "object",
              "required": [
                "url"
              ],
              "properties": {
                "url": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "There is an embedded logo on the chain, make another call to download it.",
              "type": "string",
              "enum": [
                "embedded"
              ]
            }
          ]
        }
      }
    },
    "minter": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MinterResponse",
      "type": "object",
      "required": [
        "minter"
      ],
      "properties": {
        "cap": {
          "description": "cap is a hard cap on total supply that can be achieved by minting. Note that this refers to total_supply. If None, there is unlimited cap.",
          "anyOf": [
            {
              "$ref": "#/definitions/Uint128"
            },
            {
              "type": "null"
            }
          ]
        },
        "minter": {
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "module": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Module",
      "description": "A struct describing a token module, provided with the instantiation message this struct is used to record the info about the module and how/if it should be instantiated",
      "type": "object",
      "required": [
        "address",
        "is_mutable"
      ],
      "properties": {
        "address": {
          "$ref": "#/definitions/AndrAddr"
        },
        "is_mutable": {
          "type": "boolean"
        },
        "name": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "AndrAddr": {
          "description": "An address that can be used within the Andromeda ecosystem. Inspired by the cosmwasm-std `Addr` type. https://github.com/CosmWasm/cosmwasm/blob/2a1c698520a1aacedfe3f4803b0d7d653892217a/packages/std/src/addresses.rs#L33\n\nThis address can be one of two things: 1. A valid human readable address e.g. `cosmos1...` 2. A valid Andromeda VFS path e.g. `/home/user/app/component`\n\nVFS paths can be local in the case of an app and can be done by referencing `./component` they can also contain protocols for cross chain communication. A VFS path is usually structured as so:\n\n`<protocol>://<chain (required if ibc used)>/<path>` or `ibc://cosmoshub-4/user/app/component`",
          "type": "string",
          "pattern": "(^((([A-Za-z0-9]+://)?([A-Za-z0-9.\\-_]{2,40}/)))?((~[a-z0-9]{2,}|(lib|home))(/[A-Za-z0-9.\\-_]{2,40}?)*(/)?)$)|(^(~[a-z0-9]{2,}|/(lib|home))(/[A-Za-z0-9.\\-_]{2,40}?)*(/)?$)|(^[a-z0-9]{2,}$)|(^\\.(/[A-Za-z0-9.\\-_]{2,40}?)*(/)?$)"
        }
      }
    },
    "module_ids": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_String",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "original_publisher": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PublisherResponse",
      "type": "object",
      "required": [
        "original_publisher"
      ],
      "properties": {
        "original_publisher": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "owner": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractOwnerResponse",
      "type": "object",
      "required": [
        "owner"
      ],
      "properties": {
        "owner": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ownership_request": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractPotentialOwnerResponse",
      "type": "object",
      "properties": {
        "potential_owner": {
          "anyOf": [
            {
              "$ref": "#/definitions/Addr"
            },
            {
              "type": "null"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "permissioned_actions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_String",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "permissions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_PermissionInfo",
      "type": "array",
      "items": {
        "$ref": "#/definitions/PermissionInfo"
      },
      "definitions": {
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Permission": {
          "description": "An enum to represent a user's permission for an action\n\n- **Blacklisted** - The user cannot perform the action until after the provided expiration - **Limited** - The user can perform the action while uses are remaining and before the provided expiration **for a permissioned action** - **Whitelisted** - The user can perform the action until the provided expiration **for a permissioned action**\n\nExpiration defaults to `Never` if not provided",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "blacklisted"
              ],
              "properties": {
                "blacklisted": {
                  "anyOf": [
                    {
                      "$ref": "#/definitions/Expiration"
                    },
                    {
                      "type": "null"
                    }
                  ]
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "limited"
              ],
              "properties": {
                "limited": {
                  "type": "object",
                  "required": [
                    "uses"
                  ],
                  "properties": {
                    "expiration": {
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Expiration"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "uses": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "whitelisted"
              ],
              "properties": {
                "whitelisted": {
                  "anyOf": [
                    {
                      "$ref": "#/definitions/Expiration"
                    },
                    {
                      "type": "null"
                    }
                  ]
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PermissionInfo": {
          "type": "object",
          "required": [
            "action",
            "actor",
            "permission"
          ],
          "properties": {
            "action": {
              "type": "string"
            },
            "actor": {
              "type": "string"
            },
            "permission": {
              "$ref": "#/definitions/Permission"
            }
          },
          "additionalProperties": false
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "token_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TokenInfoResponse",
      "type": "object",
      "required": [
        "decimals",
        "name",
        "symbol",
        "total_supply"
      ],
      "properties": {
        "decimals": {
          "type": "integer",
          "format": "uint8",
          "minimum": 0.0
        },
        "name": {
          "type": "string"
        },
        "symbol": {
          "type": "string"
        },
        "total_supply": {
          "$ref": "#/definitions/Uint128"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "type": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TypeResponse",
      "type": "object",
      "required": [
        "ado_type"
      ],
      "properties": {
        "ado_type": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "version": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VersionResponse",
      "type": "object",
      "required": [
        "version"
      ],
      "properties": {
        "version": {
          "type": "string"
        }
      },
      "additionalProperties": false
    }
  }
}
