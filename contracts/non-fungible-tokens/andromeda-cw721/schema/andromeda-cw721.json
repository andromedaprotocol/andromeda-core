{
  "contract_name": "andromeda-cw721",
  "contract_version": "0.2.1",
  "idl_version": "1.0.0",
  "instantiate": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "InstantiateMsg",
    "type": "object",
    "required": [
      "kernel_address",
      "minter",
      "name",
      "symbol"
    ],
    "properties": {
      "kernel_address": {
        "type": "string"
      },
      "minter": {
        "description": "The minter is the only one who can create new NFTs. This is designed for a base NFT that is controlled by an external program or contract. You will likely replace this with custom logic in custom NFTs",
        "allOf": [
          {
            "$ref": "#/definitions/AndrAddr"
          }
        ]
      },
      "name": {
        "description": "Name of the NFT contract",
        "type": "string"
      },
      "owner": {
        "type": [
          "string",
          "null"
        ]
      },
      "symbol": {
        "description": "Symbol of the NFT contract",
        "type": "string"
      }
    },
    "additionalProperties": false,
    "definitions": {
      "AndrAddr": {
        "description": "An address that can be used within the Andromeda ecosystem. Inspired by the cosmwasm-std `Addr` type. https://github.com/CosmWasm/cosmwasm/blob/2a1c698520a1aacedfe3f4803b0d7d653892217a/packages/std/src/addresses.rs#L33\n\nThis address can be one of two things: 1. A valid human readable address e.g. `cosmos1...` 2. A valid Andromeda VFS path e.g. `/home/user/app/component`\n\nVFS paths can be local in the case of an app and can be done by referencing `./component` they can also contain protocols for cross chain communication. A VFS path is usually structured as so:\n\n`<protocol>://<chain (required if ibc used)>/<path>` or `ibc://cosmoshub-4/user/app/component`",
        "type": "string"
      }
    }
  },
  "execute": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "ExecuteMsg",
    "oneOf": [
      {
        "description": "Mints a token",
        "type": "object",
        "required": [
          "mint"
        ],
        "properties": {
          "mint": {
            "type": "object",
            "required": [
              "extension",
              "owner",
              "token_id"
            ],
            "properties": {
              "extension": {
                "description": "Any custom extension used by this contract",
                "allOf": [
                  {
                    "$ref": "#/definitions/TokenExtension"
                  }
                ]
              },
              "owner": {
                "description": "The owner of the newly minter NFT",
                "type": "string"
              },
              "token_id": {
                "description": "Unique ID of the NFT",
                "type": "string"
              },
              "token_uri": {
                "description": "Universal resource identifier for this NFT Should point to a JSON file that conforms to the ERC721 Metadata JSON Schema",
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Transfers ownership of a token",
        "type": "object",
        "required": [
          "transfer_nft"
        ],
        "properties": {
          "transfer_nft": {
            "type": "object",
            "required": [
              "recipient",
              "token_id"
            ],
            "properties": {
              "recipient": {
                "type": "string"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Sends a token to another contract",
        "type": "object",
        "required": [
          "send_nft"
        ],
        "properties": {
          "send_nft": {
            "type": "object",
            "required": [
              "contract",
              "msg",
              "token_id"
            ],
            "properties": {
              "contract": {
                "type": "string"
              },
              "msg": {
                "$ref": "#/definitions/Binary"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Allows operator to transfer / send the token from the owner's account. If expiration is set, then this allowance has a time/height limit",
        "type": "object",
        "required": [
          "approve"
        ],
        "properties": {
          "approve": {
            "type": "object",
            "required": [
              "spender",
              "token_id"
            ],
            "properties": {
              "expires": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Expiration"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "spender": {
                "type": "string"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Remove previously granted Approval",
        "type": "object",
        "required": [
          "revoke"
        ],
        "properties": {
          "revoke": {
            "type": "object",
            "required": [
              "spender",
              "token_id"
            ],
            "properties": {
              "spender": {
                "type": "string"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Approves an address for all tokens owned by the sender",
        "type": "object",
        "required": [
          "approve_all"
        ],
        "properties": {
          "approve_all": {
            "type": "object",
            "required": [
              "operator"
            ],
            "properties": {
              "expires": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Expiration"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "operator": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Remove previously granted ApproveAll permission",
        "type": "object",
        "required": [
          "revoke_all"
        ],
        "properties": {
          "revoke_all": {
            "type": "object",
            "required": [
              "operator"
            ],
            "properties": {
              "operator": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Burns a token, removing all data related to it. The ID of the token is still reserved.",
        "type": "object",
        "required": [
          "burn"
        ],
        "properties": {
          "burn": {
            "type": "object",
            "required": [
              "token_id"
            ],
            "properties": {
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Archives a token, causing it to be immutable but readable",
        "type": "object",
        "required": [
          "archive"
        ],
        "properties": {
          "archive": {
            "type": "object",
            "required": [
              "token_id"
            ],
            "properties": {
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Assigns a `TransferAgreement` for a token",
        "type": "object",
        "required": [
          "transfer_agreement"
        ],
        "properties": {
          "transfer_agreement": {
            "type": "object",
            "required": [
              "token_id"
            ],
            "properties": {
              "agreement": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/TransferAgreement"
                  },
                  {
                    "type": "null"
                  }
                ]
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Mint multiple tokens at a time",
        "type": "object",
        "required": [
          "batch_mint"
        ],
        "properties": {
          "batch_mint": {
            "type": "object",
            "required": [
              "tokens"
            ],
            "properties": {
              "tokens": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/MintMsg"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "extension"
        ],
        "properties": {
          "extension": {
            "type": "object",
            "required": [
              "msg"
            ],
            "properties": {
              "msg": {
                "$ref": "#/definitions/ExecuteMsg"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "amp_receive"
        ],
        "properties": {
          "amp_receive": {
            "$ref": "#/definitions/AMPPkt"
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_owner"
        ],
        "properties": {
          "update_owner": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_operators"
        ],
        "properties": {
          "update_operators": {
            "type": "object",
            "required": [
              "operators"
            ],
            "properties": {
              "operators": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "update_app_contract"
        ],
        "properties": {
          "update_app_contract": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "set_permission"
        ],
        "properties": {
          "set_permission": {
            "type": "object",
            "required": [
              "action",
              "actor",
              "permission"
            ],
            "properties": {
              "action": {
                "type": "string"
              },
              "actor": {
                "$ref": "#/definitions/AndrAddr"
              },
              "permission": {
                "$ref": "#/definitions/Permission"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "remove_permission"
        ],
        "properties": {
          "remove_permission": {
            "type": "object",
            "required": [
              "action",
              "actor"
            ],
            "properties": {
              "action": {
                "type": "string"
              },
              "actor": {
                "$ref": "#/definitions/AndrAddr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "permission_action"
        ],
        "properties": {
          "permission_action": {
            "type": "object",
            "required": [
              "action"
            ],
            "properties": {
              "action": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "rates"
        ],
        "properties": {
          "rates": {
            "$ref": "#/definitions/RatesMessage"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "AMPCtx": {
        "type": "object",
        "required": [
          "id",
          "origin",
          "previous_sender"
        ],
        "properties": {
          "id": {
            "type": "integer",
            "format": "uint64",
            "minimum": 0.0
          },
          "origin": {
            "type": "string"
          },
          "origin_username": {
            "anyOf": [
              {
                "$ref": "#/definitions/AndrAddr"
              },
              {
                "type": "null"
              }
            ]
          },
          "previous_sender": {
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "AMPMsg": {
        "description": "This struct defines how the kernel parses and relays messages between ADOs If the desired recipient is via IBC then namespacing must be employed The attached message must be a binary encoded execute message for the receiving ADO Funds can be attached for an individual message and will be attached accordingly",
        "type": "object",
        "required": [
          "config",
          "funds",
          "message",
          "recipient"
        ],
        "properties": {
          "config": {
            "description": "When the message should reply, defaults to Always",
            "allOf": [
              {
                "$ref": "#/definitions/AMPMsgConfig"
              }
            ]
          },
          "funds": {
            "description": "Any funds to be attached to the message, defaults to an empty vector",
            "type": "array",
            "items": {
              "$ref": "#/definitions/Coin"
            }
          },
          "message": {
            "description": "The message to be sent to the recipient",
            "allOf": [
              {
                "$ref": "#/definitions/Binary"
              }
            ]
          },
          "recipient": {
            "description": "The message recipient, can be a contract/wallet address or a namespaced URI",
            "allOf": [
              {
                "$ref": "#/definitions/AndrAddr"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "AMPMsgConfig": {
        "description": "The configuration of the message to be sent.\n\nUsed when a sub message is generated for the given AMP Msg (only used in the case of Wasm Messages).",
        "type": "object",
        "required": [
          "direct",
          "exit_at_error",
          "reply_on"
        ],
        "properties": {
          "direct": {
            "description": "Whether to send the message directly to the given recipient",
            "type": "boolean"
          },
          "exit_at_error": {
            "description": "Determines whether the operation should terminate or proceed upon a failed message",
            "type": "boolean"
          },
          "gas_limit": {
            "description": "An optional imposed gas limit for the message",
            "type": [
              "integer",
              "null"
            ],
            "format": "uint64",
            "minimum": 0.0
          },
          "ibc_config": {
            "anyOf": [
              {
                "$ref": "#/definitions/IBCConfig"
              },
              {
                "type": "null"
              }
            ]
          },
          "reply_on": {
            "description": "When the message should reply, defaults to Always",
            "allOf": [
              {
                "$ref": "#/definitions/ReplyOn"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "AMPPkt": {
        "description": "An Andromeda packet contains all message protocol related data, this is what is sent between ADOs when communicating It contains an original sender, if used for authorisation the sender must be authorised The previous sender is the one who sent the message A packet may contain several messages which allows for message batching",
        "type": "object",
        "required": [
          "ctx",
          "messages"
        ],
        "properties": {
          "ctx": {
            "$ref": "#/definitions/AMPCtx"
          },
          "messages": {
            "description": "Any messages associated with the packet",
            "type": "array",
            "items": {
              "$ref": "#/definitions/AMPMsg"
            }
          }
        },
        "additionalProperties": false
      },
      "AndrAddr": {
        "description": "An address that can be used within the Andromeda ecosystem. Inspired by the cosmwasm-std `Addr` type. https://github.com/CosmWasm/cosmwasm/blob/2a1c698520a1aacedfe3f4803b0d7d653892217a/packages/std/src/addresses.rs#L33\n\nThis address can be one of two things: 1. A valid human readable address e.g. `cosmos1...` 2. A valid Andromeda VFS path e.g. `/home/user/app/component`\n\nVFS paths can be local in the case of an app and can be done by referencing `./component` they can also contain protocols for cross chain communication. A VFS path is usually structured as so:\n\n`<protocol>://<chain (required if ibc used)>/<path>` or `ibc://cosmoshub-4/user/app/component`",
        "type": "string"
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Decimal": {
        "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
        "type": "string"
      },
      "ExecuteMsg": {
        "oneOf": [
          {
            "description": "Mints a token",
            "type": "object",
            "required": [
              "mint"
            ],
            "properties": {
              "mint": {
                "type": "object",
                "required": [
                  "extension",
                  "owner",
                  "token_id"
                ],
                "properties": {
                  "extension": {
                    "description": "Any custom extension used by this contract",
                    "allOf": [
                      {
                        "$ref": "#/definitions/TokenExtension"
                      }
                    ]
                  },
                  "owner": {
                    "description": "The owner of the newly minter NFT",
                    "type": "string"
                  },
                  "token_id": {
                    "description": "Unique ID of the NFT",
                    "type": "string"
                  },
                  "token_uri": {
                    "description": "Universal resource identifier for this NFT Should point to a JSON file that conforms to the ERC721 Metadata JSON Schema",
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Transfers ownership of a token",
            "type": "object",
            "required": [
              "transfer_nft"
            ],
            "properties": {
              "transfer_nft": {
                "type": "object",
                "required": [
                  "recipient",
                  "token_id"
                ],
                "properties": {
                  "recipient": {
                    "type": "string"
                  },
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Sends a token to another contract",
            "type": "object",
            "required": [
              "send_nft"
            ],
            "properties": {
              "send_nft": {
                "type": "object",
                "required": [
                  "contract",
                  "msg",
                  "token_id"
                ],
                "properties": {
                  "contract": {
                    "type": "string"
                  },
                  "msg": {
                    "$ref": "#/definitions/Binary"
                  },
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Allows operator to transfer / send the token from the owner's account. If expiration is set, then this allowance has a time/height limit",
            "type": "object",
            "required": [
              "approve"
            ],
            "properties": {
              "approve": {
                "type": "object",
                "required": [
                  "spender",
                  "token_id"
                ],
                "properties": {
                  "expires": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "spender": {
                    "type": "string"
                  },
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Remove previously granted Approval",
            "type": "object",
            "required": [
              "revoke"
            ],
            "properties": {
              "revoke": {
                "type": "object",
                "required": [
                  "spender",
                  "token_id"
                ],
                "properties": {
                  "spender": {
                    "type": "string"
                  },
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Approves an address for all tokens owned by the sender",
            "type": "object",
            "required": [
              "approve_all"
            ],
            "properties": {
              "approve_all": {
                "type": "object",
                "required": [
                  "operator"
                ],
                "properties": {
                  "expires": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "operator": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Remove previously granted ApproveAll permission",
            "type": "object",
            "required": [
              "revoke_all"
            ],
            "properties": {
              "revoke_all": {
                "type": "object",
                "required": [
                  "operator"
                ],
                "properties": {
                  "operator": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Burns a token, removing all data related to it. The ID of the token is still reserved.",
            "type": "object",
            "required": [
              "burn"
            ],
            "properties": {
              "burn": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Archives a token, causing it to be immutable but readable",
            "type": "object",
            "required": [
              "archive"
            ],
            "properties": {
              "archive": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Assigns a `TransferAgreement` for a token",
            "type": "object",
            "required": [
              "transfer_agreement"
            ],
            "properties": {
              "transfer_agreement": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "agreement": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/TransferAgreement"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Mint multiple tokens at a time",
            "type": "object",
            "required": [
              "batch_mint"
            ],
            "properties": {
              "batch_mint": {
                "type": "object",
                "required": [
                  "tokens"
                ],
                "properties": {
                  "tokens": {
                    "type": "array",
                    "items": {
                      "$ref": "#/definitions/MintMsg"
                    }
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "extension"
            ],
            "properties": {
              "extension": {
                "type": "object",
                "required": [
                  "msg"
                ],
                "properties": {
                  "msg": {
                    "$ref": "#/definitions/ExecuteMsg"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "amp_receive"
            ],
            "properties": {
              "amp_receive": {
                "$ref": "#/definitions/AMPPkt"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_owner"
            ],
            "properties": {
              "update_owner": {
                "type": "object",
                "required": [
                  "address"
                ],
                "properties": {
                  "address": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_operators"
            ],
            "properties": {
              "update_operators": {
                "type": "object",
                "required": [
                  "operators"
                ],
                "properties": {
                  "operators": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "update_app_contract"
            ],
            "properties": {
              "update_app_contract": {
                "type": "object",
                "required": [
                  "address"
                ],
                "properties": {
                  "address": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "set_permission"
            ],
            "properties": {
              "set_permission": {
                "type": "object",
                "required": [
                  "action",
                  "actor",
                  "permission"
                ],
                "properties": {
                  "action": {
                    "type": "string"
                  },
                  "actor": {
                    "$ref": "#/definitions/AndrAddr"
                  },
                  "permission": {
                    "$ref": "#/definitions/Permission"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "remove_permission"
            ],
            "properties": {
              "remove_permission": {
                "type": "object",
                "required": [
                  "action",
                  "actor"
                ],
                "properties": {
                  "action": {
                    "type": "string"
                  },
                  "actor": {
                    "$ref": "#/definitions/AndrAddr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "permission_action"
            ],
            "properties": {
              "permission_action": {
                "type": "object",
                "required": [
                  "action"
                ],
                "properties": {
                  "action": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "rates"
            ],
            "properties": {
              "rates": {
                "$ref": "#/definitions/RatesMessage"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Expiration": {
        "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
        "oneOf": [
          {
            "description": "AtHeight will expire when `env.block.height` >= height",
            "type": "object",
            "required": [
              "at_height"
            ],
            "properties": {
              "at_height": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            "additionalProperties": false
          },
          {
            "description": "AtTime will expire when `env.block.time` >= time",
            "type": "object",
            "required": [
              "at_time"
            ],
            "properties": {
              "at_time": {
                "$ref": "#/definitions/Timestamp"
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Never will never expire. Used to express the empty variant",
            "type": "object",
            "required": [
              "never"
            ],
            "properties": {
              "never": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "IBCConfig": {
        "type": "object",
        "properties": {
          "recovery_addr": {
            "anyOf": [
              {
                "$ref": "#/definitions/AndrAddr"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "LocalRate": {
        "type": "object",
        "required": [
          "rate_type",
          "recipients",
          "value"
        ],
        "properties": {
          "description": {
            "type": [
              "string",
              "null"
            ]
          },
          "rate_type": {
            "$ref": "#/definitions/LocalRateType"
          },
          "recipients": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Recipient"
            }
          },
          "value": {
            "$ref": "#/definitions/LocalRateValue"
          }
        },
        "additionalProperties": false
      },
      "LocalRateType": {
        "type": "string",
        "enum": [
          "additive",
          "deductive"
        ]
      },
      "LocalRateValue": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "percent"
            ],
            "properties": {
              "percent": {
                "$ref": "#/definitions/PercentRate"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "flat"
            ],
            "properties": {
              "flat": {
                "$ref": "#/definitions/Coin"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "MintMsg": {
        "type": "object",
        "required": [
          "extension",
          "owner",
          "token_id"
        ],
        "properties": {
          "extension": {
            "description": "Any custom extension used by this contract",
            "allOf": [
              {
                "$ref": "#/definitions/TokenExtension"
              }
            ]
          },
          "owner": {
            "description": "The owner of the newly minter NFT",
            "type": "string"
          },
          "token_id": {
            "description": "Unique ID of the NFT",
            "type": "string"
          },
          "token_uri": {
            "description": "Universal resource identifier for this NFT Should point to a JSON file that conforms to the ERC721 Metadata JSON Schema",
            "type": [
              "string",
              "null"
            ]
          }
        },
        "additionalProperties": false
      },
      "PercentRate": {
        "type": "object",
        "required": [
          "percent"
        ],
        "properties": {
          "percent": {
            "$ref": "#/definitions/Decimal"
          }
        },
        "additionalProperties": false
      },
      "Permission": {
        "description": "An enum to represent a user's permission for an action\n\n- **Blacklisted** - The user cannot perform the action until after the provided expiration - **Limited** - The user can perform the action while uses are remaining and before the provided expiration **for a permissioned action** - **Whitelisted** - The user can perform the action until the provided expiration **for a permissioned action**\n\nExpiration defaults to `Never` if not provided",
        "oneOf": [
          {
            "type": "object",
            "required": [
              "blacklisted"
            ],
            "properties": {
              "blacklisted": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Expiration"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "limited"
            ],
            "properties": {
              "limited": {
                "type": "object",
                "required": [
                  "uses"
                ],
                "properties": {
                  "expiration": {
                    "anyOf": [
                      {
                        "$ref": "#/definitions/Expiration"
                      },
                      {
                        "type": "null"
                      }
                    ]
                  },
                  "uses": {
                    "type": "integer",
                    "format": "uint32",
                    "minimum": 0.0
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "whitelisted"
            ],
            "properties": {
              "whitelisted": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/Expiration"
                  },
                  {
                    "type": "null"
                  }
                ]
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Rate": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "local"
            ],
            "properties": {
              "local": {
                "$ref": "#/definitions/LocalRate"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "contract"
            ],
            "properties": {
              "contract": {
                "$ref": "#/definitions/AndrAddr"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "RatesMessage": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "set_rate"
            ],
            "properties": {
              "set_rate": {
                "type": "object",
                "required": [
                  "action",
                  "rate"
                ],
                "properties": {
                  "action": {
                    "type": "string"
                  },
                  "rate": {
                    "$ref": "#/definitions/Rate"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "remove_rate"
            ],
            "properties": {
              "remove_rate": {
                "type": "object",
                "required": [
                  "action"
                ],
                "properties": {
                  "action": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Recipient": {
        "description": "A simple struct used for inter-contract communication. The struct can be used in two ways:\n\n1. Simply just providing an `AndrAddr` which will treat the communication as a transfer of any related funds 2. Providing an `AndrAddr` and a `Binary` message which will be sent to the contract at the resolved address\n\nThe `Binary` message can be any message that the contract at the resolved address can handle.",
        "type": "object",
        "required": [
          "address"
        ],
        "properties": {
          "address": {
            "$ref": "#/definitions/AndrAddr"
          },
          "ibc_recovery_address": {
            "anyOf": [
              {
                "$ref": "#/definitions/AndrAddr"
              },
              {
                "type": "null"
              }
            ]
          },
          "msg": {
            "anyOf": [
              {
                "$ref": "#/definitions/Binary"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "additionalProperties": false
      },
      "ReplyOn": {
        "description": "Use this to define when the contract gets a response callback. If you only need it for errors or success you can select just those in order to save gas.",
        "oneOf": [
          {
            "description": "Always perform a callback after SubMsg is processed",
            "type": "string",
            "enum": [
              "always"
            ]
          },
          {
            "description": "Only callback if SubMsg returned an error, no callback on success case",
            "type": "string",
            "enum": [
              "error"
            ]
          },
          {
            "description": "Only callback if SubMsg was successful, no callback on error case",
            "type": "string",
            "enum": [
              "success"
            ]
          },
          {
            "description": "Never make a callback - this is like the original CosmosMsg semantics",
            "type": "string",
            "enum": [
              "never"
            ]
          }
        ]
      },
      "Timestamp": {
        "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
        "allOf": [
          {
            "$ref": "#/definitions/Uint64"
          }
        ]
      },
      "TokenExtension": {
        "description": "https://docs.opensea.io/docs/metadata-standards Replicates OpenSea Metadata Standards",
        "type": "object",
        "required": [
          "publisher"
        ],
        "properties": {
          "publisher": {
            "description": "The original publisher of the token",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "TransferAgreement": {
        "description": "A struct used to represent an agreed transfer of a token. The `purchaser` may use the `Transfer` message for this token as long as funds are provided equalling the `amount` defined in the agreement.",
        "type": "object",
        "required": [
          "amount",
          "purchaser"
        ],
        "properties": {
          "amount": {
            "description": "The amount required for the purchaser to transfer ownership of the token",
            "allOf": [
              {
                "$ref": "#/definitions/Coin"
              }
            ]
          },
          "purchaser": {
            "description": "The address of the purchaser",
            "type": "string"
          }
        },
        "additionalProperties": false
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      },
      "Uint64": {
        "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
        "type": "string"
      }
    }
  },
  "query": {
    "$schema": "http://json-schema.org/draft-07/schema#",
    "title": "QueryMsg",
    "oneOf": [
      {
        "description": "Owner of the given token by ID",
        "type": "object",
        "required": [
          "owner_of"
        ],
        "properties": {
          "owner_of": {
            "type": "object",
            "required": [
              "token_id"
            ],
            "properties": {
              "include_expired": {
                "type": [
                  "boolean",
                  "null"
                ]
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Approvals for a given address (paginated)",
        "type": "object",
        "required": [
          "all_operators"
        ],
        "properties": {
          "all_operators": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "include_expired": {
                "type": [
                  "boolean",
                  "null"
                ]
              },
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "owner": {
                "type": "string"
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Amount of tokens minted by the contract",
        "type": "object",
        "required": [
          "num_tokens"
        ],
        "properties": {
          "num_tokens": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "The data of a token",
        "type": "object",
        "required": [
          "nft_info"
        ],
        "properties": {
          "nft_info": {
            "type": "object",
            "required": [
              "token_id"
            ],
            "properties": {
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "The data of a token and any approvals assigned to it",
        "type": "object",
        "required": [
          "all_nft_info"
        ],
        "properties": {
          "all_nft_info": {
            "type": "object",
            "required": [
              "token_id"
            ],
            "properties": {
              "include_expired": {
                "type": [
                  "boolean",
                  "null"
                ]
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "All tokens minted by the contract owned by a given address (paginated)",
        "type": "object",
        "required": [
          "tokens"
        ],
        "properties": {
          "tokens": {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "owner": {
                "type": "string"
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "All tokens minted by the contract (paginated)",
        "type": "object",
        "required": [
          "all_tokens"
        ],
        "properties": {
          "all_tokens": {
            "type": "object",
            "properties": {
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "If the token is archived",
        "type": "object",
        "required": [
          "is_archived"
        ],
        "properties": {
          "is_archived": {
            "type": "object",
            "required": [
              "token_id"
            ],
            "properties": {
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "The transfer agreement for the token",
        "type": "object",
        "required": [
          "transfer_agreement"
        ],
        "properties": {
          "transfer_agreement": {
            "type": "object",
            "required": [
              "token_id"
            ],
            "properties": {
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "The current config of the contract",
        "type": "object",
        "required": [
          "contract_info"
        ],
        "properties": {
          "contract_info": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "extension"
        ],
        "properties": {
          "extension": {
            "type": "object",
            "required": [
              "msg"
            ],
            "properties": {
              "msg": {
                "$ref": "#/definitions/QueryMsg"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "minter"
        ],
        "properties": {
          "minter": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "approval"
        ],
        "properties": {
          "approval": {
            "type": "object",
            "required": [
              "spender",
              "token_id"
            ],
            "properties": {
              "include_expired": {
                "type": [
                  "boolean",
                  "null"
                ]
              },
              "spender": {
                "type": "string"
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "description": "Return approvals that a token has Return type: `ApprovalsResponse`",
        "type": "object",
        "required": [
          "approvals"
        ],
        "properties": {
          "approvals": {
            "type": "object",
            "required": [
              "token_id"
            ],
            "properties": {
              "include_expired": {
                "type": [
                  "boolean",
                  "null"
                ]
              },
              "token_id": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "owner"
        ],
        "properties": {
          "owner": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "operators"
        ],
        "properties": {
          "operators": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "type"
        ],
        "properties": {
          "type": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "kernel_address"
        ],
        "properties": {
          "kernel_address": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "original_publisher"
        ],
        "properties": {
          "original_publisher": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "block_height_upon_creation"
        ],
        "properties": {
          "block_height_upon_creation": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "is_operator"
        ],
        "properties": {
          "is_operator": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "version"
        ],
        "properties": {
          "version": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "balance"
        ],
        "properties": {
          "balance": {
            "type": "object",
            "required": [
              "address"
            ],
            "properties": {
              "address": {
                "$ref": "#/definitions/AndrAddr"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "permissions"
        ],
        "properties": {
          "permissions": {
            "type": "object",
            "required": [
              "actor"
            ],
            "properties": {
              "actor": {
                "type": "string"
              },
              "limit": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              },
              "start_after": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "permissioned_actions"
        ],
        "properties": {
          "permissioned_actions": {
            "type": "object",
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "get_rate"
        ],
        "properties": {
          "get_rate": {
            "type": "object",
            "required": [
              "action"
            ],
            "properties": {
              "action": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        },
        "additionalProperties": false
      },
      {
        "type": "object",
        "required": [
          "andr_hook"
        ],
        "properties": {
          "andr_hook": {
            "$ref": "#/definitions/AndromedaHook"
          }
        },
        "additionalProperties": false
      }
    ],
    "definitions": {
      "AndrAddr": {
        "description": "An address that can be used within the Andromeda ecosystem. Inspired by the cosmwasm-std `Addr` type. https://github.com/CosmWasm/cosmwasm/blob/2a1c698520a1aacedfe3f4803b0d7d653892217a/packages/std/src/addresses.rs#L33\n\nThis address can be one of two things: 1. A valid human readable address e.g. `cosmos1...` 2. A valid Andromeda VFS path e.g. `/home/user/app/component`\n\nVFS paths can be local in the case of an app and can be done by referencing `./component` they can also contain protocols for cross chain communication. A VFS path is usually structured as so:\n\n`<protocol>://<chain (required if ibc used)>/<path>` or `ibc://cosmoshub-4/user/app/component`",
        "type": "string"
      },
      "AndromedaHook": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "on_execute"
            ],
            "properties": {
              "on_execute": {
                "type": "object",
                "required": [
                  "payload",
                  "sender"
                ],
                "properties": {
                  "payload": {
                    "$ref": "#/definitions/Binary"
                  },
                  "sender": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "on_funds_transfer"
            ],
            "properties": {
              "on_funds_transfer": {
                "type": "object",
                "required": [
                  "amount",
                  "payload",
                  "sender"
                ],
                "properties": {
                  "amount": {
                    "$ref": "#/definitions/Funds"
                  },
                  "payload": {
                    "$ref": "#/definitions/Binary"
                  },
                  "sender": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "on_token_transfer"
            ],
            "properties": {
              "on_token_transfer": {
                "type": "object",
                "required": [
                  "recipient",
                  "sender",
                  "token_id"
                ],
                "properties": {
                  "recipient": {
                    "type": "string"
                  },
                  "sender": {
                    "type": "string"
                  },
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Binary": {
        "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
        "type": "string"
      },
      "Coin": {
        "type": "object",
        "required": [
          "amount",
          "denom"
        ],
        "properties": {
          "amount": {
            "$ref": "#/definitions/Uint128"
          },
          "denom": {
            "type": "string"
          }
        }
      },
      "Cw20Coin": {
        "type": "object",
        "required": [
          "address",
          "amount"
        ],
        "properties": {
          "address": {
            "type": "string"
          },
          "amount": {
            "$ref": "#/definitions/Uint128"
          }
        },
        "additionalProperties": false
      },
      "Funds": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "native"
            ],
            "properties": {
              "native": {
                "$ref": "#/definitions/Coin"
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "cw20"
            ],
            "properties": {
              "cw20": {
                "$ref": "#/definitions/Cw20Coin"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "QueryMsg": {
        "oneOf": [
          {
            "description": "Owner of the given token by ID",
            "type": "object",
            "required": [
              "owner_of"
            ],
            "properties": {
              "owner_of": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "include_expired": {
                    "type": [
                      "boolean",
                      "null"
                    ]
                  },
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Approvals for a given address (paginated)",
            "type": "object",
            "required": [
              "all_operators"
            ],
            "properties": {
              "all_operators": {
                "type": "object",
                "required": [
                  "owner"
                ],
                "properties": {
                  "include_expired": {
                    "type": [
                      "boolean",
                      "null"
                    ]
                  },
                  "limit": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "owner": {
                    "type": "string"
                  },
                  "start_after": {
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Amount of tokens minted by the contract",
            "type": "object",
            "required": [
              "num_tokens"
            ],
            "properties": {
              "num_tokens": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "The data of a token",
            "type": "object",
            "required": [
              "nft_info"
            ],
            "properties": {
              "nft_info": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "The data of a token and any approvals assigned to it",
            "type": "object",
            "required": [
              "all_nft_info"
            ],
            "properties": {
              "all_nft_info": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "include_expired": {
                    "type": [
                      "boolean",
                      "null"
                    ]
                  },
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "All tokens minted by the contract owned by a given address (paginated)",
            "type": "object",
            "required": [
              "tokens"
            ],
            "properties": {
              "tokens": {
                "type": "object",
                "required": [
                  "owner"
                ],
                "properties": {
                  "limit": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "owner": {
                    "type": "string"
                  },
                  "start_after": {
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "All tokens minted by the contract (paginated)",
            "type": "object",
            "required": [
              "all_tokens"
            ],
            "properties": {
              "all_tokens": {
                "type": "object",
                "properties": {
                  "limit": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "start_after": {
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "If the token is archived",
            "type": "object",
            "required": [
              "is_archived"
            ],
            "properties": {
              "is_archived": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "The transfer agreement for the token",
            "type": "object",
            "required": [
              "transfer_agreement"
            ],
            "properties": {
              "transfer_agreement": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "The current config of the contract",
            "type": "object",
            "required": [
              "contract_info"
            ],
            "properties": {
              "contract_info": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "extension"
            ],
            "properties": {
              "extension": {
                "type": "object",
                "required": [
                  "msg"
                ],
                "properties": {
                  "msg": {
                    "$ref": "#/definitions/QueryMsg"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "minter"
            ],
            "properties": {
              "minter": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "approval"
            ],
            "properties": {
              "approval": {
                "type": "object",
                "required": [
                  "spender",
                  "token_id"
                ],
                "properties": {
                  "include_expired": {
                    "type": [
                      "boolean",
                      "null"
                    ]
                  },
                  "spender": {
                    "type": "string"
                  },
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "description": "Return approvals that a token has Return type: `ApprovalsResponse`",
            "type": "object",
            "required": [
              "approvals"
            ],
            "properties": {
              "approvals": {
                "type": "object",
                "required": [
                  "token_id"
                ],
                "properties": {
                  "include_expired": {
                    "type": [
                      "boolean",
                      "null"
                    ]
                  },
                  "token_id": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "owner"
            ],
            "properties": {
              "owner": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "operators"
            ],
            "properties": {
              "operators": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "type": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "kernel_address"
            ],
            "properties": {
              "kernel_address": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "original_publisher"
            ],
            "properties": {
              "original_publisher": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "block_height_upon_creation"
            ],
            "properties": {
              "block_height_upon_creation": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "is_operator"
            ],
            "properties": {
              "is_operator": {
                "type": "object",
                "required": [
                  "address"
                ],
                "properties": {
                  "address": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "version"
            ],
            "properties": {
              "version": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "balance"
            ],
            "properties": {
              "balance": {
                "type": "object",
                "required": [
                  "address"
                ],
                "properties": {
                  "address": {
                    "$ref": "#/definitions/AndrAddr"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "permissions"
            ],
            "properties": {
              "permissions": {
                "type": "object",
                "required": [
                  "actor"
                ],
                "properties": {
                  "actor": {
                    "type": "string"
                  },
                  "limit": {
                    "type": [
                      "integer",
                      "null"
                    ],
                    "format": "uint32",
                    "minimum": 0.0
                  },
                  "start_after": {
                    "type": [
                      "string",
                      "null"
                    ]
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "permissioned_actions"
            ],
            "properties": {
              "permissioned_actions": {
                "type": "object",
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "get_rate"
            ],
            "properties": {
              "get_rate": {
                "type": "object",
                "required": [
                  "action"
                ],
                "properties": {
                  "action": {
                    "type": "string"
                  }
                },
                "additionalProperties": false
              }
            },
            "additionalProperties": false
          },
          {
            "type": "object",
            "required": [
              "andr_hook"
            ],
            "properties": {
              "andr_hook": {
                "$ref": "#/definitions/AndromedaHook"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "Uint128": {
        "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
        "type": "string"
      }
    }
  },
  "migrate": null,
  "sudo": null,
  "responses": {
    "all_nft_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AllNftInfoResponse_for_TokenExtension",
      "type": "object",
      "required": [
        "access",
        "info"
      ],
      "properties": {
        "access": {
          "description": "Who can transfer the token",
          "allOf": [
            {
              "$ref": "#/definitions/OwnerOfResponse"
            }
          ]
        },
        "info": {
          "description": "Data on the token itself,",
          "allOf": [
            {
              "$ref": "#/definitions/NftInfoResponse_for_TokenExtension"
            }
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Approval": {
          "type": "object",
          "required": [
            "expires",
            "spender"
          ],
          "properties": {
            "expires": {
              "description": "When the Approval expires (maybe Expiration::never)",
              "allOf": [
                {
                  "$ref": "#/definitions/Expiration"
                }
              ]
            },
            "spender": {
              "description": "Account that can transfer/send the token",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "NftInfoResponse_for_TokenExtension": {
          "type": "object",
          "required": [
            "extension"
          ],
          "properties": {
            "extension": {
              "description": "You can add any custom metadata here when you extend cw721-base",
              "allOf": [
                {
                  "$ref": "#/definitions/TokenExtension"
                }
              ]
            },
            "token_uri": {
              "description": "Universal resource identifier for this NFT Should point to a JSON file that conforms to the ERC721 Metadata JSON Schema",
              "type": [
                "string",
                "null"
              ]
            }
          },
          "additionalProperties": false
        },
        "OwnerOfResponse": {
          "type": "object",
          "required": [
            "approvals",
            "owner"
          ],
          "properties": {
            "approvals": {
              "description": "If set this address is approved to transfer/send the token as well",
              "type": "array",
              "items": {
                "$ref": "#/definitions/Approval"
              }
            },
            "owner": {
              "description": "Owner of the token",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "TokenExtension": {
          "description": "https://docs.opensea.io/docs/metadata-standards Replicates OpenSea Metadata Standards",
          "type": "object",
          "required": [
            "publisher"
          ],
          "properties": {
            "publisher": {
              "description": "The original publisher of the token",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "all_operators": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "OperatorsResponse",
      "type": "object",
      "required": [
        "operators"
      ],
      "properties": {
        "operators": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Approval"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Approval": {
          "type": "object",
          "required": [
            "expires",
            "spender"
          ],
          "properties": {
            "expires": {
              "description": "When the Approval expires (maybe Expiration::never)",
              "allOf": [
                {
                  "$ref": "#/definitions/Expiration"
                }
              ]
            },
            "spender": {
              "description": "Account that can transfer/send the token",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "all_tokens": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TokensResponse",
      "type": "object",
      "required": [
        "tokens"
      ],
      "properties": {
        "tokens": {
          "description": "Contains all token_ids in lexicographical ordering If there are more than `limit`, use `start_after` in future queries to achieve pagination.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "andr_hook": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Binary",
      "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
      "type": "string"
    },
    "approval": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ApprovalResponse",
      "type": "object",
      "required": [
        "approval"
      ],
      "properties": {
        "approval": {
          "$ref": "#/definitions/Approval"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Approval": {
          "type": "object",
          "required": [
            "expires",
            "spender"
          ],
          "properties": {
            "expires": {
              "description": "When the Approval expires (maybe Expiration::never)",
              "allOf": [
                {
                  "$ref": "#/definitions/Expiration"
                }
              ]
            },
            "spender": {
              "description": "Account that can transfer/send the token",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "approvals": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ApprovalsResponse",
      "type": "object",
      "required": [
        "approvals"
      ],
      "properties": {
        "approvals": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Approval"
          }
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Approval": {
          "type": "object",
          "required": [
            "expires",
            "spender"
          ],
          "properties": {
            "expires": {
              "description": "When the Approval expires (maybe Expiration::never)",
              "allOf": [
                {
                  "$ref": "#/definitions/Expiration"
                }
              ]
            },
            "spender": {
              "description": "Account that can transfer/send the token",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "balance": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BalanceResponse",
      "type": "object",
      "required": [
        "amount"
      ],
      "properties": {
        "amount": {
          "description": "Always returns a Coin with the requested denom. This may be of 0 amount if no such funds.",
          "allOf": [
            {
              "$ref": "#/definitions/Coin"
            }
          ]
        }
      },
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "block_height_upon_creation": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BlockHeightResponse",
      "type": "object",
      "required": [
        "block_height"
      ],
      "properties": {
        "block_height": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "contract_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractInfoResponse",
      "type": "object",
      "required": [
        "name",
        "symbol"
      ],
      "properties": {
        "name": {
          "type": "string"
        },
        "symbol": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "extension": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TokenExtension",
      "description": "https://docs.opensea.io/docs/metadata-standards Replicates OpenSea Metadata Standards",
      "type": "object",
      "required": [
        "publisher"
      ],
      "properties": {
        "publisher": {
          "description": "The original publisher of the token",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "get_rate": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_Rate",
      "anyOf": [
        {
          "$ref": "#/definitions/Rate"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "AndrAddr": {
          "description": "An address that can be used within the Andromeda ecosystem. Inspired by the cosmwasm-std `Addr` type. https://github.com/CosmWasm/cosmwasm/blob/2a1c698520a1aacedfe3f4803b0d7d653892217a/packages/std/src/addresses.rs#L33\n\nThis address can be one of two things: 1. A valid human readable address e.g. `cosmos1...` 2. A valid Andromeda VFS path e.g. `/home/user/app/component`\n\nVFS paths can be local in the case of an app and can be done by referencing `./component` they can also contain protocols for cross chain communication. A VFS path is usually structured as so:\n\n`<protocol>://<chain (required if ibc used)>/<path>` or `ibc://cosmoshub-4/user/app/component`",
          "type": "string"
        },
        "Binary": {
          "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
          "type": "string"
        },
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "Decimal": {
          "description": "A fixed-point decimal value with 18 fractional digits, i.e. Decimal(1_000_000_000_000_000_000) == 1.0\n\nThe greatest possible value that can be represented is 340282366920938463463.374607431768211455 (which is (2^128 - 1) / 10^18)",
          "type": "string"
        },
        "LocalRate": {
          "type": "object",
          "required": [
            "rate_type",
            "recipients",
            "value"
          ],
          "properties": {
            "description": {
              "type": [
                "string",
                "null"
              ]
            },
            "rate_type": {
              "$ref": "#/definitions/LocalRateType"
            },
            "recipients": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Recipient"
              }
            },
            "value": {
              "$ref": "#/definitions/LocalRateValue"
            }
          },
          "additionalProperties": false
        },
        "LocalRateType": {
          "type": "string",
          "enum": [
            "additive",
            "deductive"
          ]
        },
        "LocalRateValue": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "percent"
              ],
              "properties": {
                "percent": {
                  "$ref": "#/definitions/PercentRate"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "flat"
              ],
              "properties": {
                "flat": {
                  "$ref": "#/definitions/Coin"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PercentRate": {
          "type": "object",
          "required": [
            "percent"
          ],
          "properties": {
            "percent": {
              "$ref": "#/definitions/Decimal"
            }
          },
          "additionalProperties": false
        },
        "Rate": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "local"
              ],
              "properties": {
                "local": {
                  "$ref": "#/definitions/LocalRate"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "contract"
              ],
              "properties": {
                "contract": {
                  "$ref": "#/definitions/AndrAddr"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Recipient": {
          "description": "A simple struct used for inter-contract communication. The struct can be used in two ways:\n\n1. Simply just providing an `AndrAddr` which will treat the communication as a transfer of any related funds 2. Providing an `AndrAddr` and a `Binary` message which will be sent to the contract at the resolved address\n\nThe `Binary` message can be any message that the contract at the resolved address can handle.",
          "type": "object",
          "required": [
            "address"
          ],
          "properties": {
            "address": {
              "$ref": "#/definitions/AndrAddr"
            },
            "ibc_recovery_address": {
              "anyOf": [
                {
                  "$ref": "#/definitions/AndrAddr"
                },
                {
                  "type": "null"
                }
              ]
            },
            "msg": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Binary"
                },
                {
                  "type": "null"
                }
              ]
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "is_archived": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Boolean",
      "type": "boolean"
    },
    "is_operator": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "IsOperatorResponse",
      "type": "object",
      "required": [
        "is_operator"
      ],
      "properties": {
        "is_operator": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "kernel_address": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "KernelAddressResponse",
      "type": "object",
      "required": [
        "kernel_address"
      ],
      "properties": {
        "kernel_address": {
          "$ref": "#/definitions/Addr"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Addr": {
          "description": "A human readable address.\n\nIn Cosmos, this is typically bech32 encoded. But for multi-chain smart contracts no assumptions should be made other than being UTF-8 encoded and of reasonable length.\n\nThis type represents a validated address. It can be created in the following ways 1. Use `Addr::unchecked(input)` 2. Use `let checked: Addr = deps.api.addr_validate(input)?` 3. Use `let checked: Addr = deps.api.addr_humanize(canonical_addr)?` 4. Deserialize from JSON. This must only be done from JSON that was validated before such as a contract's state. `Addr` must not be used in messages sent by the user because this would result in unvalidated instances.\n\nThis type is immutable. If you really need to mutate it (Really? Are you sure?), create a mutable copy using `let mut mutable = Addr::to_string()` and operate on that `String` instance.",
          "type": "string"
        }
      }
    },
    "minter": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MinterResponse",
      "description": "Shows who can mint these tokens",
      "type": "object",
      "properties": {
        "minter": {
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false
    },
    "nft_info": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "NftInfoResponse_for_TokenExtension",
      "type": "object",
      "required": [
        "extension"
      ],
      "properties": {
        "extension": {
          "description": "You can add any custom metadata here when you extend cw721-base",
          "allOf": [
            {
              "$ref": "#/definitions/TokenExtension"
            }
          ]
        },
        "token_uri": {
          "description": "Universal resource identifier for this NFT Should point to a JSON file that conforms to the ERC721 Metadata JSON Schema",
          "type": [
            "string",
            "null"
          ]
        }
      },
      "additionalProperties": false,
      "definitions": {
        "TokenExtension": {
          "description": "https://docs.opensea.io/docs/metadata-standards Replicates OpenSea Metadata Standards",
          "type": "object",
          "required": [
            "publisher"
          ],
          "properties": {
            "publisher": {
              "description": "The original publisher of the token",
              "type": "string"
            }
          },
          "additionalProperties": false
        }
      }
    },
    "num_tokens": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "NumTokensResponse",
      "type": "object",
      "required": [
        "count"
      ],
      "properties": {
        "count": {
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "operators": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "OperatorsResponse",
      "type": "object",
      "required": [
        "operators"
      ],
      "properties": {
        "operators": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "original_publisher": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "PublisherResponse",
      "type": "object",
      "required": [
        "original_publisher"
      ],
      "properties": {
        "original_publisher": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "owner": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ContractOwnerResponse",
      "type": "object",
      "required": [
        "owner"
      ],
      "properties": {
        "owner": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "owner_of": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "OwnerOfResponse",
      "type": "object",
      "required": [
        "approvals",
        "owner"
      ],
      "properties": {
        "approvals": {
          "description": "If set this address is approved to transfer/send the token as well",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Approval"
          }
        },
        "owner": {
          "description": "Owner of the token",
          "type": "string"
        }
      },
      "additionalProperties": false,
      "definitions": {
        "Approval": {
          "type": "object",
          "required": [
            "expires",
            "spender"
          ],
          "properties": {
            "expires": {
              "description": "When the Approval expires (maybe Expiration::never)",
              "allOf": [
                {
                  "$ref": "#/definitions/Expiration"
                }
              ]
            },
            "spender": {
              "description": "Account that can transfer/send the token",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "permissioned_actions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_String",
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "permissions": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_PermissionInfo",
      "type": "array",
      "items": {
        "$ref": "#/definitions/PermissionInfo"
      },
      "definitions": {
        "Expiration": {
          "description": "Expiration represents a point in time when some event happens. It can compare with a BlockInfo and will return is_expired() == true once the condition is hit (and for every block in the future)",
          "oneOf": [
            {
              "description": "AtHeight will expire when `env.block.height` >= height",
              "type": "object",
              "required": [
                "at_height"
              ],
              "properties": {
                "at_height": {
                  "type": "integer",
                  "format": "uint64",
                  "minimum": 0.0
                }
              },
              "additionalProperties": false
            },
            {
              "description": "AtTime will expire when `env.block.time` >= time",
              "type": "object",
              "required": [
                "at_time"
              ],
              "properties": {
                "at_time": {
                  "$ref": "#/definitions/Timestamp"
                }
              },
              "additionalProperties": false
            },
            {
              "description": "Never will never expire. Used to express the empty variant",
              "type": "object",
              "required": [
                "never"
              ],
              "properties": {
                "never": {
                  "type": "object",
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Permission": {
          "description": "An enum to represent a user's permission for an action\n\n- **Blacklisted** - The user cannot perform the action until after the provided expiration - **Limited** - The user can perform the action while uses are remaining and before the provided expiration **for a permissioned action** - **Whitelisted** - The user can perform the action until the provided expiration **for a permissioned action**\n\nExpiration defaults to `Never` if not provided",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "blacklisted"
              ],
              "properties": {
                "blacklisted": {
                  "anyOf": [
                    {
                      "$ref": "#/definitions/Expiration"
                    },
                    {
                      "type": "null"
                    }
                  ]
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "limited"
              ],
              "properties": {
                "limited": {
                  "type": "object",
                  "required": [
                    "uses"
                  ],
                  "properties": {
                    "expiration": {
                      "anyOf": [
                        {
                          "$ref": "#/definitions/Expiration"
                        },
                        {
                          "type": "null"
                        }
                      ]
                    },
                    "uses": {
                      "type": "integer",
                      "format": "uint32",
                      "minimum": 0.0
                    }
                  },
                  "additionalProperties": false
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "whitelisted"
              ],
              "properties": {
                "whitelisted": {
                  "anyOf": [
                    {
                      "$ref": "#/definitions/Expiration"
                    },
                    {
                      "type": "null"
                    }
                  ]
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "PermissionInfo": {
          "type": "object",
          "required": [
            "action",
            "actor",
            "permission"
          ],
          "properties": {
            "action": {
              "type": "string"
            },
            "actor": {
              "type": "string"
            },
            "permission": {
              "$ref": "#/definitions/Permission"
            }
          },
          "additionalProperties": false
        },
        "Timestamp": {
          "description": "A point in time in nanosecond precision.\n\nThis type can represent times from 1970-01-01T00:00:00Z to 2554-07-21T23:34:33Z.\n\n## Examples\n\n``` # use cosmwasm_std::Timestamp; let ts = Timestamp::from_nanos(1_000_000_202); assert_eq!(ts.nanos(), 1_000_000_202); assert_eq!(ts.seconds(), 1); assert_eq!(ts.subsec_nanos(), 202);\n\nlet ts = ts.plus_seconds(2); assert_eq!(ts.nanos(), 3_000_000_202); assert_eq!(ts.seconds(), 3); assert_eq!(ts.subsec_nanos(), 202); ```",
          "allOf": [
            {
              "$ref": "#/definitions/Uint64"
            }
          ]
        },
        "Uint64": {
          "description": "A thin wrapper around u64 that is using strings for JSON encoding/decoding, such that the full u64 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u64` to get the value out:\n\n``` # use cosmwasm_std::Uint64; let a = Uint64::from(42u64); assert_eq!(a.u64(), 42);\n\nlet b = Uint64::from(70u32); assert_eq!(b.u64(), 70); ```",
          "type": "string"
        }
      }
    },
    "tokens": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TokensResponse",
      "type": "object",
      "required": [
        "tokens"
      ],
      "properties": {
        "tokens": {
          "description": "Contains all token_ids in lexicographical ordering If there are more than `limit`, use `start_after` in future queries to achieve pagination.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "transfer_agreement": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Nullable_TransferAgreement",
      "anyOf": [
        {
          "$ref": "#/definitions/TransferAgreement"
        },
        {
          "type": "null"
        }
      ],
      "definitions": {
        "Coin": {
          "type": "object",
          "required": [
            "amount",
            "denom"
          ],
          "properties": {
            "amount": {
              "$ref": "#/definitions/Uint128"
            },
            "denom": {
              "type": "string"
            }
          }
        },
        "TransferAgreement": {
          "description": "A struct used to represent an agreed transfer of a token. The `purchaser` may use the `Transfer` message for this token as long as funds are provided equalling the `amount` defined in the agreement.",
          "type": "object",
          "required": [
            "amount",
            "purchaser"
          ],
          "properties": {
            "amount": {
              "description": "The amount required for the purchaser to transfer ownership of the token",
              "allOf": [
                {
                  "$ref": "#/definitions/Coin"
                }
              ]
            },
            "purchaser": {
              "description": "The address of the purchaser",
              "type": "string"
            }
          },
          "additionalProperties": false
        },
        "Uint128": {
          "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
          "type": "string"
        }
      }
    },
    "type": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TypeResponse",
      "type": "object",
      "required": [
        "ado_type"
      ],
      "properties": {
        "ado_type": {
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "version": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "VersionResponse",
      "type": "object",
      "required": [
        "version"
      ],
      "properties": {
        "version": {
          "type": "string"
        }
      },
      "additionalProperties": false
    }
  }
}
